@node Language facilities
@chapter Language facilities



@menu
* Alternative tokens::                        Alternative spellings of common operators.
* Booleans::                                  Proper booleans in the C programming language.
* Non-returning functions::                   Specifying that functions never return.
* Variable alignment::                        Aligment of variables and data types.
* Member offsets::                            Getting the offset of members of a structure.
@end menu



@node Alternative tokens
@section Alternative tokens

@hfindex iso646.h
@cpindex Alternative tokens
@cpindex Tokens, alternative
The @sc{ISO}@tie{}C90 standard was amended in 1995 to
include alternative spellings of common operators,
referred to as C alternative tokens.

@table @code
@item and
@fnindex and
@code{&&}

@item and_eq
@fnindex and_eq
@code{&=}

@item bitand
@fnindex bitand
@code{&}

@item bitor
@fnindex bitor
@code{|}

@item compl
@fnindex compl
@code{~}

@item not
@fnindex not
@code{!}

@item not_eq
@fnindex not_eq
@code{!=}

@item or
@fnindex or
@code{||}

@item or_eq
@fnindex or_eq
@code{|=}

@item xor
@fnindex xor
@code{^}

@item xor_eq
@fnindex xor_eq
@code{^=}
@end table

These alternative spellings are implemented as a
group of macro constants, and are made available
by including the header file @file{<iso646.h>}.
They were added because a concern that the standard
names are difficult to type on some keyboard-layouts.

Use of these alternative tokens are discouraged,
they lessen the readability of your code. If it is
difficult to type some characters without yout
keyboard-layout, it is better to change keyboard-layout.



@node Booleans
@section Booleans

@hfindex stdbool.h
@cpindex Booleans
@tpindex bool
@tpindex _Bool
@lvindex true
@lvindex false
@lvindex __bool_true_false_are_defined
The @sc{ISO}@tie{}C99 standard added the keyword
@code{_Bool}, as well as a set macro definitions
that are made available by including the header
file @file{<stdbool.h>}.

@table @code
@item bool
Expands to @code{_Bool}, an integer data
type. Any non-zero value (any true value)
is stored as 1, to avoid integer overflows,
that may occur when using @code{int}, and
not using @code{!!} when casting to @code{int}.

@item true
Has the value 1, and represents a true value.

@item false
Has the value 0, and represents a false value.

@item __bool_true_false_are_defined
Will be defined if the other three macros
are define. So, it will will be defined if
the header file is included.

@end table

The macros @code{bool}, @code{true}, and @code{false}
may be removed and become built-in the future; or at
least, the right to undefined them may be removed.



@node Non-returning functions
@section Non-returning functions

@hfindex stdnoreturn.h
@cpindex Non-returning functions
@cpindex @code{noreturn}
@cpindex @code{_Noreturn}
@tpindex noreturn
@tpindex _Noreturn
A few, such as @code{exit}, functions never return,
and cannot fail. The @sc{ISO}@tie{}C11 added a
function qualifier that lets you specify that a
functon never returns, that is, the process exits
or changes process image before returning. Note
that this is not the same thing only returning on
failure, like the @code{exec} functions. This
qualifier is known as @code{_Noreturn} and must be
used at the beginning the the function declaration.

By including the header file @file{<stdnoreturn.h>},
the macro definition @code{noreturn} is made
available as an alias for @code{_Noreturn} .

@lvindex __noreturn_is_defined
Note that @code{slibc}, in contrast to some C
standard libraries, does not defined, the
non-standardised, @code{__noreturn_is_defined} macro.

Some compilers have supported this before
@sc{ISO}@tie{}C11, by specifying the function
attribute @code{noreturn}. Note that including the
@file{<stdnoreturn.h>} header file conflicts with
this compiler feature. Because of this,
@file{<stdnoreturn.h>} is considered non-portable
by @code{slibc}. If you want to use both, GCC
supports @code{__attribute__((__noreturn__))} as
a synonym for @code{__attribute__((noreturn))}.



@node Variable alignment
@section Variable alignment

@hfindex stdalign.h
@cpindex Variable alignment
@cpindex Alignment, variables
@cpindex @code{alignas}
@fnindex @code{alignof}
@cpindex @code{_Alignas}
@fnindex @code{_Alignof}
The @sc{ISO}@tie{}C11 added a variable qualifier
and a function used to specify the aligned of
variable, and retrieve the alignment of a type,
respectively, These are called @code{_Alignas}
and @code{_Alignof}, by including the header file
@file{<stdalign.h>}, the macros @code{alignas}
and @code{alignof}, that alias this keywords, are
defined.

Declaring a variable with the qualifier
@code{alignas(TYPE)} specifies that the variable
should have the alignment of the type @code{TYPE}.

The function call @code{alignof(TYPE)}, returns
the alignment of the type @code{TYPE}.



@node Member offsets
@section Member offsets

@hfindex stddef.h
@cpindex Member offsets
@cpindex Structure member offsets
@cpindex Offsets of structure member
@fnindex @code{offsetof}
@sc{ANSI}@tie{}C defines the macro @code{offsetof}
to be declared by the header file @file{<stddef.h>}.
It returns the offset, in bytes, of a direct or
indirect member in a @code{struct} or @code{union}.
The call @code{offsetof(type, member)} returns the
offset of the member @code{member} in the type
@code{type}.

As en example, consider the structure
@example
struct example
@{
  char offset_is_0[16];
  char offset_is_16[16];
@}
@end example
@code{offsetof(struct example, offset_is_0)}
evaluates to 0 because it is at the top of the
structure. @code{offsetof(struct example, offset_is_16)}
evaluates to 16 because the member above it in the
structure has offset 0 and size 16. 0 + 16 = 16.

@code{offsetof} does not support bit field-@code{struct}:s.
@code{offsetof} is also known to be problematic in C++,
because C++ supports redefining operators.

